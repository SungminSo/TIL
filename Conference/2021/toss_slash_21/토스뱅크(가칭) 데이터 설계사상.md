# 토스뱅크(가칭) 데이터 설계사상

IT업무의 본질 : 데이터를 어떻게 효율적으로 읽어들이고 쓰느냐 -> 데이터가 핵심
     
## 테이블의 통합과 분리
- 업무에 따라 통합 혹은 분리 판단 필요
- ex. 대출기본, 카드기본은 심사내역은 분리 / 연체 이후는 통합
	- 왜? : 
		- 심사는 평가항목이 대출/카드가 상이한 항목이 많음
		- 따라서 테이블을 심사내역 하나로 통합했을 때 불리한 점이 많음
		- 반면 연체 이후는 연체일, 연체금액 등 공통적인 항목이 많고 이후에 발생하는 법적 절차 테이블들은 고객별 데이터
		- 따라서 통합이 조금 더 효율적일 수 있음
		- 설계자의 판단에 의해 결정되는 사항
- ex. 보증
	- 보증 업무는 업무별, 기관별, 상품별로 나눠짐
	- 업무별: 심사/청약/보상
	- 업무/기관/상품별로 테이블을 구성하면 그 가지수만큼의 테이블이 증가됨(ex. 3 * 6 * 10)
	- 테이블의 숫자가 너무 많으므로 어느정도의 통합 필요
      	
- 테이블 통합과 분리 방법
	- OneToOne Type
		- 슈퍼테이블/서브테이블로 구성하는 방식
		- ex. 고객테이블(슈퍼) - 법인/개인테이블(서브)
		- 테이블 join이 비교적 쉬운편
		- 각 테이블 개별 속성을 조회할때는 각각의 개별 테이블과 join해야하는 단점이 있음
	- Plus Type
		- 각각 개별테이블로 구성하는 방식
		- ex. 법인고객테이블/개인고객테이블
		- 개별 테이블은 칼럼 추가시 각 테이블에서만 작업하면 되기 때문에 확정성이 괜찮고 업무 디펜던시가 제거된다는 장점이 있음
		- join이 각각 들어가야 하기 때문에 관리 용이성은 좋지 않음
	- Single Type
		- 통합 테이블 방식
		- ex. 고객테이블
		- join 성능이 우수하고 관리 용이성이 좋음
		- 여러 프로그램에서 하나의 테이블만 바라보게 되고 alter가 자주 발생하게 된다는 단점이 있음
		- 테이블/프로그램 ownership 문제가 발생할 수 있다는 단점이 있음
		- 대량의 데이터 발생에 따라 성능저하 이슈가 발생할 수 있어 index 파티션 전략이 중요
           
- 해법은?
	- 공통분모는 최대한 모으는게 좋음
	- 데이터의 양이 적으면 성능상 이슈가 없기 때문에 되도록 통합하는 것이 좋음
	- 데이터의 양이 많다면 슈퍼/서브 테이블로 분리를 생각해보면 좋음
		- ex. 트랜잭션을 분리해서 공통적인 속성은 먼저 입력받고 개별 속성은 팝업등으로 따로 입력받는 방식으로 처리
       
## 순환 참조의 활용
- 자기 자신 테이블의 PK를 일반 속성으로 넣는 방식으로 설계
- `CONNECt BY START WITH` 구문으로 선행 상태 추적 가능
- 주로 제조업의 부품관리, BOM 구조 등에서 많이 활용 됨
     
## 테이블 종류의 체계적 관리
- 프로젝트를 진행하다면 테이블명이 굉장히 다양해질 수 있음
- 명칭에 의해 헷갈리는 경우가 있을 수 있음
	- ex. 이력 테이블 vs 내역 테이블
		- 이력(History) 테이블 : 메인 테이블을 바탕으로 구성된 하위 자식테이블로 볼 수 있음
		- 내역(Transaction) 테이블 : 시점 정보(메인)
     
## 비대면 대량 거래 설계
- 주요 키인 계좌번호, 대출신청번호, 금리산출번호 등의 컬럼 자리수 설계
- ex. 계좌번호
	- 고객이 기억해야하는 번호이기 때문에 자릿수가 짧아야 함
	- 하지만 비대면 특성상 계좌를 빈번히 발생시킬 수 있기 때문에 번호 자체가 모두 Full이 찰 수 있음
	- 안쓰는 계좌는 delete해야하지만 은행권에서 데이터를 날리는것은 명확한 준칙 하에 이루어져야 하므로 쉽지 않음
	- 컬럼 자릿수를 늘릴 수는 있지만 관려 계좌 테이블과 자식 테이블을 alter해야하고 관련 프로그램들을 수정해야 하므로 이 역시 쉽지 않음
	- categorizing 및 사용량 예측으로 적절히 대응할 수 있음 
     
## 성능 최적화 설계	
- ex. 채번
	- 채번 entity
		- 장점
			- 순차적으로 엄격하게 채번
			- 체계적으로 채번
		- 단점
			- 객체(entity) 증가
			- lock 사용으로 느린 채번(채번 테이블에서 lock 발생)
	- 시퀀스
		- 장점
			- nextval로 사용하기 편함
			- 가장 빠른 성능
			- 최소한의 lock 발생
		- 단점
			- 체계 부여가 불편
			- 빈 번호 발생 가능
			- 객체(시퀀스) 증가
	- Max + 1
		- 장점
			- 별도의 객체가 필요하지 않음
			- 순차적으로 엄격하게 채번
			- 체계적인 채번 가능
		- 단점
			- lock 사용으로 느린 채번(insert할 테이블에서 lock 발생)
			- 예외 상황 발생 가능
			- 최대값 관리에 부담
- ex. 배치 대용량 처리
	- for-loop를 통해서 DBMS를 여러번 call하는 것은 지양
	- 다건 select 해서 insert 하거나, merge 문을 허용해서 DBMS call을 최소화하는 방식 사용
      
데이터 설계는 쉽지않다.     
핵심은 얼마나 잘 고민하고 논의하였는가